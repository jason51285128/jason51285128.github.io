---
layout: post
title: linux系统编程 
categories: linux
tags: kernel
---

1.	文件系统及IO

	1.	磁盘及分区表
	
	1.	linux文件系统
	
	1.	IO操作
	
	1.	IO 模型
	
	1. memory map IO
	
1.	内存管理
1.	进程调度

	1.	进程的组成：代码段、数据段、栈、文件描述表、信号记录表、参数表、环境表指针等等
	
	1.	创建新的进程
	
		*	system，启动shell，在shell中创建新的进程，并且等待进程执行完成后再返回
		*	execv，替换当前进程映像
		*	fork，复制当前进程，fork在父进程返回子进程的pid，在子进程则返还0，父子进程执行COW
		*	vfork，vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，
			父进程阻塞，直到子进程执行了exec()或者exit()。
		*	clone，可以选择性的继承父进程的资源，常用于创建线程
		*	wait，等待子进程结束，阻塞
		*	waitpid， 等待子进程结束，可以设置为阻塞，也可以设置为非阻塞
		*	僵尸进程，子进程必须等父进程结束，或者父进程的wait函数返还，系统才会释放子进程的资源，如果子进程结束
		而他的父进程还没有结束，则此时子进程将会成为僵尸进程
		
	1.	进程间通信
	
		1.	信号：中断一个进程的执行，让行进入信号处理程序
			1.	发送信号，kill，可以用kill -l查看可以发送的信号类型
			1.	为信号设置处理函数，signal，如果程序没有设置信号的处理函数，则执行系统默认处理函数
			1. 	信号是一种异步非阻塞通信方式，需要进程调度模块参与，内核为信号维护（blocked，pending，handler
				）数据接口，调度一个进程执行前，新处理该进程pending且未block的信号，由于用户自定义的信号
				处理函数在用户态，在执行用户自定义的信号处理函数时，需要从内核态切到用户态，并且在
				进程的用户态栈上为信号处理函数建立新的栈，该过程叫做信号的捕获
		
		1. 	管道：单向通信，内核维护缓冲区，匿名管道，命名管道，自带互斥与同步，面向字节流。匿名管道的
			生命周期随进程，及所有亲源关系的进程都退出时，管道销毁。命名管道的声明周期随系统。
			
		1.	消息队列：在进程间传递格式化的数据，生命周期随系统
		
		1.	信号量：原子操作，加1或者减1，常作为同步机制，同样分为有名信号量和无名信号量，无名
			信号量用于线程间或者具有亲缘关系的进程之间的同步，无名信号的值保存在内存中，生命周期随进程
			有名信号量，可用于任意线程、进程通信，值保存在文件系统中（/dev/shm），生命周期随系统
		
		1.	共享内存：多个进程的页表项指向同一页物理内存，效率高，但需要考虑同步，生命周期随内核
		
		
	1.	什么是进程、线程？二者有何关系？
	
		从概念上讲，进程是操作系统资源分配的单位，包括代码段、数据段、栈、堆、文件描述符、信号表等等，
		进程构成了程序运行的环境，而线程是程序的执行流，也就是在进程中干活的，线程只有自己代码段和栈，而
		共享进程的数据段、堆、文件描述符等资源，一个进程可以只有一个线程，并且至少要有一个线程，当然也可以
		有多个线程。举一个例子来说，进程就好像是提供了演员表演的场地：包括舞台、灯光、音箱等资源，而线程
		可以认为是在其中表演的演员。
		
		从linux实现来说，操作系统将线程也当做进程来看待，应为处理器就没有提供“线程”的模型，不管是hyper-thread
		还是multi-core等X86并行架构，都是将多个物理或者逻辑CPU封装在一块芯片上，而CPU提供的最小运行环境都是
		进程（称之为task）。在实现上，linux将线程当成轻量级进程，简单的说就是线程的PCB指向其所属进程的PCB，
		从而实现共享进程的资源，而在调度上将其当成普通的进程进行调度。
		
	1.	进程有哪几种状态？孤儿进程？僵尸进程？
	
		linux进程状态：R S D T Z X
		
		R(task_running)：正在执行或者已就绪
		
		S(task_interruptable): 可中断睡眠，等待IO或者事件响应，当IO就绪时，进程恢复执行，并且此时进程可以响应
		中断、信号等。
		
		D(task_uninterruptable): 不可中断睡眠，等待IO或者事件响应，当就绪时，恢复响应，
		但是进程不接受信号，中断等，也就是该过程不可被打断。如vfork调用，父进程将进出入该状态
		
		T(task_stopped or task_traced): 暂停或者跟踪状态，向进程发送SIGSTOP信号，进程将进入该状态（
		废除进程出入D状态），再向进程发送SIGCONT，进程将恢复运行，trace用于进程调试
		
		Z(task_zombie)：进程已退出，但是父进程没有替它收尸（父进程调用wait、waitpid），进程结束时，释放其占有的资源，
		向他的父进程发送SIGCHILD信号，然后进入僵尸态(僵尸态是每个进程都会经历的状态)，
		等待父进程调用wait或者waitpid，获取子进程退出的信息，然后子进程才会进入X状态，最终
		释放其task_struct
		
		如果父进程没有调用wait或者waitpid，那么子进程将进入僵尸状态，而无法退出，占用系统pid，task_struc资源
		（是有限的）
		
		避免僵尸进程的方法：阻塞调用wait，异步调用waitpid，注册SIGCHILD信号为忽略，或者在信号处理函数中
		调用wait、waitpid
		
		孤儿进程：如果父进程在子进程之前退出，那么子进程则成为孤儿继承，寄养给init进程，由init进程负责
		进程退出
		
		守护进程：在后台运行，不关联任何终端的进程
		
		X(task_dead): 进程即将退出，并释放其task_stuct
		
	1. 	进程调度的常用算法
	
		FIFO SPF RR 优先级调度
		
	1.	进程调度的时机
	
		1、进程状态转换的时刻：进程终止、进程睡眠；

		2、当前进程的时间片用完时（current->counter=0）；

		3、设备驱动程序
		
		4、进程从中断、异常及系统调用返回到用户态时；
		
		时机1，进程要调用sleep（）或exit（）等函数进行状态转换，这些函数会主动调用调度程序进行进程调度；
		
		时机2，由于进程的时间片是由时钟中断来更新的，因此，这种情况和时机4是一样的。
		
		时机3，当设备驱动程序执行长而重复的任务时，直接调用调度程序。在每次反复循环中，驱动程序都检查
		need_resched的值，如果必要，则调用调度程序schedule()主动放弃CPU。
		
		时机4，如前所述，不管是从中断、异常还是系统调用返回，最终都调用ret_from_sys_call（），
		由这个函数进行调度标志的检测，如果必要，则调用调用调度程序。那么，为什么从系统调用返回时
		要调用调度程序呢？这当然是从效率考虑。从系统调用返回意味着要离开内核态而返回到用户态，而状
		态的转换要花费一定的时间，因此，在返回到用户态前，系统把在内核态该处理的事全部做完。
		
	1.	linux IO模型
	
		IO的两个阶段：数据准备，驱动程序拷贝数据到内核缓冲区
		数据拷贝：内核将数据从内核缓冲区拷贝到用户态
		
		1.	同步阻塞
		1.	同步非阻塞：轮询
		1.	IO多路复用
		1.	信号驱动（数据准备好时，内核发信号给进程，进程自己将数据从内核缓冲区拷贝到进程）
		1.	异步IO（数据准备好，且内核将数据拷贝到进程，再通知进程，进程直接使用）
		![IO模型]({{site.baseurl}}/assets/images/linux_dev1.png)
		
	1.	进程（线程）间同步
	
		互斥锁
		信号量
		读写锁
		
		
	1.	死锁
	
		两个进程互相请求资源
		
		避免方法：分配给某个进程的资源要么全部分配，要么全部不分配，及资源静态分配
		
		资源动态检查： 银行家算法
		
	1.	线程池
	
		预先占用线程、减少线程创建和销毁的开销
		
		同步控制、管理
		
		
	1.	页面置换算法
	
		最近未使用页面置换算法（NRU） FIFO  最近最少使用页面置换算法（LRU）
		
		
1.	线程：进程中的一个执行体

	*	线程和进程的区别：进程有自己独立的代码段、数据段、栈，运行环境，创建
	一个新的进程时，新进程和父进程是完成独立的，而线程则共享进程的数据段
	以及运行环境，只是有自己独立的代码段和栈
	
	*	多线程编程接口：pthread_create/pthread_join/pthread_exit/pthread_cancle
	
	*	多线程同步控制
	
			*	信号量：通过对一个变量的原子操作，来控制线程执行的时序
			
			*	互斥量：获取到锁的线程才能运行，其他线程只能等待
		
		